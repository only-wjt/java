---
title: interview 
tags:interview,essay
grammar_cjkRuby: true
---


## 反向代理是什么，有什么作用
### 使用代理的作用
#### 提高访问速度 
由于目标主机返回的数据会存放在代理服务器的硬盘中，因此下一次客户再访问相同的站点数据时，会直接从代理服务器的硬盘中读取，起到了缓存的作用，尤其对于热门网站能明显提高访问速度。

#### 防火墙作用 
由于所有的客户机请求都必须通过代理服务器访问远程站点，因此可以在代理服务器上设限，过滤掉某些不安全信息。同时正向代理中上网者可以隐藏自己的IP,免受攻击。

#### 突破访问限制 
互联网上有许多开发的代理服务器，客户机在访问受限时，可通过不受限的代理服务器访问目标站点，通俗说，我们使用的翻墙浏览器就是利用了代理服务器，可以直接访问外网。

 ### 正向代理
 &emsp;&emsp;我们可以先从正向代理入手，正向代理一般用来作为对访问不到的资源的代理，我们知道从谁那得到的资源，但是资源处不知道具体是谁得到。

![Diagram](./attachments/1539759743844.drawio.html)

&emsp;&emsp;就想A向B借钱，但是B没有钱，于是B就向C借钱，然后把借来的钱给A，A并不知道这是B从C那借来的钱。

&emsp;&emsp; 正向代理（forward proxy） ，一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理。

### 反向代理

&emsp;&emsp; 反向代理（Reverse Proxy），以`代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，`并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器。 
&emsp;&emsp; 理解起来有些抽象，可以这么说：A向B借钱，B没有拿自己的钱，而是悄悄地向C借钱，拿到钱之后再交给A,A以为是B的钱，他并不知道C的存在。 

![Diagram](./attachments/1539760221643.drawio.html)

### 正向代理和反向代理的区别； 

 - 位置不同 
 正向代理，架设在客户机和目标主机之间； 
 反向代理，架设在服务器端；
 - 代理对象不同 
正向代理，代理客户端，服务端不知道实际发起请求的客户端； 
反向代理，代理服务端，客户端不知道实际提供服务的服务端； 

![Diagram](./attachments/1539760796389.drawio.html)

&emsp;&emsp; 备注：正向代理–HTTP代理为多个人提供翻墙服务；反向代理–百度外卖为多个商户提供平台给某个用户提供外卖服务。
- 用途不同 
正向代理，为在防火墙内的局域网客户端提供访问Internet的途径； 
反向代理，将防火墙后面的服务器提供给Internet访问；
- 安全性不同 
正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此必须采取安全措施以确保仅为授权的客户端提供服务； 
反向代理对外都是透明的，访问者并不知道自己访问的是哪一个代理。

 - 正向代理的应用
    1. 访问原来无法访问的资源 
    2. 用作缓存，加速访问速度 
    3. 对客户端访问授权，上网进行认证 
    4. 代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息

 - 反向代理的应用
    1. 保护内网安全 
    2. 负载均衡 
    3. 缓存，减少服务器的压力 
       Nginx作为最近较火的反向代理服务器，安装在目的主机端，主要用于转发客户机请求，后台有多个http服务器提供服务，nginx的功能就是把请求转发给后台的服务器，决定哪台目标主机来处理当前请求。

## 总结
&emsp;&emsp;正向代理是从客户端的角度出发，服务于特定用户（比如说一个局域网内的客户）以访问非特定的服务；反向代理正好与此相反，从服务端的角度出发，服务于非特定用户（通常是所有用户），已访问特定的服务。 

## nginx的作用，以及实现负载均衡[更深层次的理解](https://blog.csdn.net/duxingxia356/article/details/49820013)

&emsp;&emsp; Nginx是一个轻量级、高性能、稳定性高、并发性好的HTTP和反向代理服务器，应用很广泛。

### 主要作用

#### 反向代理          
&emsp;&emsp; 是用来代理服务器的，代理我们要访问的目标服务器。代理服务器接受请求，然后将请求转发给内部网络的服务器(集群化)，并将从服务器上得到的结果返回给客户端，此时代理服务器对外就表现为一个服务器。

#### 负载均衡

&emsp;&emsp; 多在高并发情况下需要使用。其原理就是将数据流量分摊到多个服务器执行，减轻每台服务器的压力，多台服务器(集群)共同完成工作任务，从而提高了数据的吞吐量。
&emsp;&emsp; Nginx可使用的负载均衡策略有：轮询（默认）、权重、ip_hash、url_hash(第三方)、fair(第三方)

&emsp;&emsp; 负载均衡也是Nginx常用的一个功能，负载均衡其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。简单而言就是当有2台或以上服务器时，根据规则随机的将请求分发到指定的服务器上处理，负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡。而Nginx目前支持自带3种负载均衡策略，还有2种常用的第三方策略。

- RR 
按照轮询（默认）方式进行负载，每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。虽然这种方式简便、成本低廉。但缺点是：可靠性低和负载分配不均衡。

- 权重 
指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。

````
upstream test{
     server localhost:8080 weight=9;
     server localhost:8081 weight=1;
}
````

此时8080和8081分别占90%和10%。

- ip_hash 
上面的2种方式都有一个问题，那就是下一个请求来的时候请求可能分发到另外一个服务器，当我们的程序不是无状态的时候（采用了session保存数据），这时候就有一个很大的很问题了，比如把登录信息保存到了session中，那么跳转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器，那么就需要用iphash了，iphash的每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。

````
upstream test {
    ip_hash;
    server localhost:8080;
    server localhost:8081;
}
````
- fair(第三方) 
按后端服务器的响应时间来分配请求，响应时间短的优先分配。

````
upstream backend { 
    fair; 
    server localhost:8080;
    server localhost:8081;
}
````

- url_hash(第三方) 
按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法。

````
upstream backend { 
    hash $request_uri; 
    hash_method crc32; 
    server localhost:8080;
    server localhost:8081;
} 
````

#### 动静分离
&emsp;&emsp; Nginx提供的动静分离是指把动态请求和静态请求分离开，合适的服务器处理相应的请求，使整个服务器系统的性能、效率更高。
&emsp;&emsp; Nginx可以根据配置对不同的请求做不同转发，这是动态分离的基础。静态请求对应的静态资源可以直接放在Nginx上做缓冲，更好的做法是放在相应的缓冲服务器上。动态请求由相应的后端服务器处理。

## mysql主从复制的作用和原理

### 一、什么是主从复制?
&emsp;&emsp;主从复制，是用来建立一个和主数据库完全一样的数据库环境，称为从数据库；主数据库一般是准实时的业务数据库。

### 二、主从复制的作用（好处，或者说为什么要做主从）重点!
&emsp;&emsp;1、做数据的热备，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。
&emsp;&emsp;2、架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。
&emsp;&emsp;3、读写分离，使数据库能支撑更大的并发。在报表中尤其重要。由于部分报表sql语句非常的慢，导致锁表，影响前台服务。如果前台使用master，报表使用slave，那么报表sql将不会造成前台锁，保证了前台速度。

### 三、主从复制的原理（重中之重，面试必问）：
&emsp;&emsp;1.数据库有个bin-log二进制文件，记录了所有sql语句。
&emsp;&emsp;2.我们的目标就是把主数据库的bin-log文件的sql语句复制过来。
&emsp;&emsp;3.让其在从数据的relay-log重做日志文件中再执行一次这些sql语句即可。
&emsp;&emsp;4.下面的主从配置就是围绕这个原理配置
&emsp;&emsp;5.具体需要三个线程来操作：
&emsp;&emsp;&emsp;&emsp;1.binlog输出线程:每当有从库连接到主库的时候，主库都会创建一个线程然后发送binlog内容到从库。在从库里，当复制开始的时候，从库就会创建两个线程进行处理：
&emsp;&emsp;&emsp;&emsp;2.从库I/O线程:当START SLAVE语句在从库开始执行之后，从库创建一个I/O线程，该线程连接到主库并请求主库发送binlog里面的更新记录到从库上。从库I/O线程读取主库的binlog输出线程发送的更新并拷贝这些更新到本地文件，其中包括relay log文件。

&emsp;&emsp;&emsp;&emsp;3.从库的SQL线程:从库创建一个SQL线程，这个线程读取从库I/O线程写到relay log的更新事件并执行。

![主从复制](https://www.github.com/only-wjt/images/raw/master/小书匠/主从复制.png)

![主从复制辅助图](https://www.github.com/only-wjt/images/raw/master/小书匠/主从复制2.png)

&emsp;&emsp;可以知道，对于每一个主从复制的连接，都有三个线程。拥有多个从库的主库为每一个连接到主库的从库创建一个binlog输出线程，每一个从库都有它自己的I/O线程和SQL线程。
&emsp;&emsp;步骤一：主库db的更新事件(update、insert、delete)被写到binlog
&emsp;&emsp;步骤二：从库发起连接，连接到主库
&emsp;&emsp;步骤三：此时主库创建一个binlog dump thread线程，把binlog的内容发送到从库
&emsp;&emsp;步骤四：从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log.
&emsp;&emsp;步骤五：还会创建一个SQL线程，从relay log里面读取内容，从Exec_Master_Log_Pos位置开始执行读取到的更新事件，将更新内容写入到slave的db.

## try catch的执行顺序
try{//正常执行的代码}catch (Exception e){//出错后执行的代码}finally{//无论正常执行还是出错,之后都会执行的代码}//跟上面try catch无关的代码正常执行的代码如果出现异常,就不会执行出现异常语句后面的所有正常代码。异常可能会被捕获掉,比如上面catch声明的是捕获Exception,那么所有Exception包括子类都会被捕获,但如Error或者是Throwable但又不是Exception(Exception继承Throwable)就不会被捕获。如果异常被捕获,就会执行catch里面的代码.如果异常没有被捕获,就会往外抛出,相当于这整个方法出现了异常。finally中的代码只要执行进了try catch永远都会被执行.执行完finally中的代码,如果异常被捕获就会执行外面跟这个try catch无关的代码.否则就会继续往外抛出异常。
return无论在哪里,只要执行到就会返回,但唯一一点不同的是如果return在try或者catch中,即使返回了,最终finally中的代码都会被执行.这种情况最常用的是打开了某些资源后必须关闭,比如打开了一个OutputStream,那就应该在finally中关闭,这样无论有没有出现异常,都会被关闭。

---------------------

本文来自 L_D_Y_K 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/L_D_Y_K/article/details/78166356?utm_source=copy 